# Vue Element Pro（ 二 ）

<a name="HEgzY"></a>
## 登录
<a name="BA4tS"></a>
### 工程目录构建
参考前端工程化规范 [https://www.yuque.com/linman/rules/eirhux](https://www.yuque.com/linman/rules/eirhux) 构建目录：

```
|- src/global 
|  ├  request
|  ├  service
|  └  storage
```

在 src 文件夹中创建 global 文件夹，里面创建 request 、service 、storage 三个文件夹分别放置请求、服务、存储相关文件。

<a name="bHUbY"></a>
### 存储文件构建
在 src/storage 文件夹中新建 index.js 、storage.js 、session.js 、cookie.js 。

```
|- src/global 
|  ├  ...
|  ├  storage
|  |  ├  cookie.js 
|  |  ├  session.js
|  |  ├  storage.js
|  |  └  index.js
```

cookie.js 用于管理浏览器 cookie 的封装方法，可参考一下代码：

```javascript
class MyCookie {
  get(name) {
    const cookieName = `${encodeURIComponent(name)}=`;
    const cookieStart = document.cookie.indexOf(cookieName);
    let cookieValue = null;
    if (cookieStart > -1) {
      let cookieEnd = document.cookie.indexOf(";", cookieStart);
      if (cookieEnd === -1) {
        cookieEnd = document.cookie.length;
      }
      cookieValue = decodeURIComponent(
        document.cookie.substring(cookieStart + cookieName.length, cookieEnd)
      );
    }
    return cookieValue;
  }

  set(name, value, expires, path, domain, secure) {
    let cookieText = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
    if (expires instanceof Date) {
      cookieText += `; expires=${expires.toGMTString()}`;
    }
    if (path) {
      cookieText += `; path=${path}`;
    }
    if (domain) {
      cookieText += `; domain=${domain}`;
    }
    if (secure) {
      cookieText += "; secure";
    }
    document.cookie = cookieText;
  }

  delete(name, path, domain, secure) {
    this.set(name, "", new Date(0), path, domain, secure);
  }
}

export default MyCookie;
```

session.js 用于管理浏览器 session 的封装方法，可参考一下代码：

```javascript
class SessionStorage {
  constructor() {
    this.prefix = "pro_";
    this.storage = window.sessionStorage;
  }

  set(key, value) {
    const prefixKey = this.prefix + key;
    const data = JSON.stringify(value);
    this.storage.setItem(prefixKey, data);
  }

  get(key) {
    const prefixKey = this.prefix + key;
    const data = this.storage.getItem(prefixKey);
    return JSON.parse(data);
  }

  delete(key) {
    const prefixKey = this.prefix + key;
    this.removeItem(prefixKey);
  }
}

export default SessionStorage;
```

storage.js 用于管理浏览器 storage 的封装方法，可参考一下代码：

```javascript
class MyStorage {
  constructor() {
    this.prefix = "pro_";
    this.storage = window.localStorage;
  }

  // exp/秒，默认 60 * 60 * 24 = 1 天
  set(key, value, exp = 60 * 60 * 24) {
    const timestamp = Date.now();
    const data = JSON.stringify({ value, exp, timestamp });
    const prefixKey = this.prefix + key;
    this.storage.setItem(prefixKey, data);
  }

  get(key) {
    const prefixKey = this.prefix + key;
    let data = this.storage.getItem(prefixKey);
    if (!data) {
      return false;
    }
    data = JSON.parse(data);
    const exp = data.exp * 1000;
    const { timestamp } = data;
    const { value } = data;
    const dataNow = Date.now();
    if (dataNow > timestamp + exp) {
      this.delete(key);
      return false;
    }
    return value;
  }

  delete(key) {
    const prefixKey = this.prefix + key;
    this.storage.removeItem(prefixKey);
  }
}

export default MyStorage;
```

index.js 为上述 cookie、session、storage 的实例化入口文件，同时包含 map 数据存储类型。

```javascript
/*
 ** DataStore 变量缓存器
 ** 方便我们在不同的类中访问和修改变量
 ** 相当于全局变量使用
 **
 ** map 使用方法
 ** import DataStore  from '@/global/storage/index.js';
 ** const userInfoInDataStore = DataStore.map.get('userInfo');
 ** DataStore.map.set('userInfo',storageUserInfo);
 **
 ** 同时封装使用 strorage、session、cookie
 ** storage
 ** session
 ** cookie
 */

import MyCookie from "./cookie";
import MyStorage from "./storage";
import MySession from "./session";

class DataStore {
  constructor() {
    this.init();
  }

  init() {
    this.map = new Map();
    this.storage = new MyStorage();
    this.session = new MySession();
    this.cookie = new MyCookie();
  }

  static getInstance() {
    if (!DataStore.instance) {
      DataStore.instance = new DataStore();
    }
    return DataStore.instance;
  }

  getToken() {
    return this.storage.get("token");
  }

  setToken(token) {
    this.storage.set("token", token);
  }

  clear() {
    localStorage.clear();
    sessionStorage.clear();
    window.location.reload();
  }
}

export default DataStore.getInstance();
```
<a name="uwybC"></a>
### 
<a name="tr5Fo"></a>
### 请求文件构建
在 src/request 文件夹中新建 axios.js、api.js 。

```
|- src/global 
|  ├  ...
|  ├  request
|  |  ├  axios.js 
|  |  └  api.js
```

api.js 用于管理 api ，本项目的 api 请参看 easymook 中 aitschool/vue-element-pro 中的文档，可参考一下代码：

```javascript
const PREFIX = "";
const VERSION = "V0.0.1";
export default {
  version: VERSION,
  phoneCode: `${PREFIX}/api/sms/phone`,
  loginPassword: `${PREFIX}/api/login/password`,
  loginSMS: `${PREFIX}/api/login/sms`,
  userInfo: `${PREFIX}/api/userInfo`
};
```

axios.js 用于封装 axios 请求，使用前需要使用 npm 或者 yarn 安装一下。

```javascript
import { Message } from "element-ui";
import DataStore from "@/global/storage/index";
import axios from "axios";
axios.defaults.timeout = 20000;

// 添加一个请求拦截器（ 一般用于鉴权 )
axios.interceptors.request.use(
  config => {
    const newConfig = { ...config };
    const TOKEN = DataStore.getToken();
    if (TOKEN) {
      newConfig.headers.Authorization = `Bearer ${TOKEN}`;
    }
    return newConfig;
  },
  error => Promise.reject(error)
);

// 全局错误处理
const handleErrorRequest = error => {
  const { response } = error;
  const status = response ? response.status : 408;

  if (response) {
    const { data } = response;
    const { errors } = data;
    const message = data.message || "服务器发送错误，请稍后再试";
    if (status === 401) {
      console.log("没有登录");
      DataStore.clear();
      console.log(error);
    } else if (status === 419) {
      console.log("页面过期");
      DataStore.clear();
    } else if (status === 422 || status === 423 || status === 429) {
      Object.keys(errors).forEach(errorKey => {
        const errorValue = errors[errorKey].join("\n");
        Message.error(errorValue);
      });
    } else {
      Message.error(message);
    }
  } else {
    Message.error("网络超时");
  }
};

// 添加响应拦截器
axios.interceptors.response.use(
  res => {
    // 兼容包了一层 { code, data } 的情况
    switch (true) {
      case res.data && res.data.code === 200:
        return res.data.data;
      case res.data && res.data.code !== 200:
        Message.error(res.data.message);
        return Promise.reject(res.data);
      default:
        return res.data;
    }
  },
  error => {
    handleErrorRequest(error);
    return Promise.reject(error);
  }
);

/* [请求库]
 ** @params url         { string }   @default => '' [接口地址]
 ** @params data/params { object }   @default => {} [发送数据]
 ** @params config      { object }   配置
 */

export default {
  post(url = "", data = {}, config = {}) {
    return axios.post(url, data, config);
  },

  put(url = "", data = {}, config = {}) {
    return axios.put(url, data, config);
  },

  get(url, params = {}, config = {}) {
    const OPTIONS = Object.assign({ params }, config);
    return axios.get(url, OPTIONS);
  },

  delete(url = "", params = {}, config = {}) {
    const OPTIONS = Object.assign({ params }, config);
    return axios.delete(url, OPTIONS);
  }
};
```

<a name="eCUIS"></a>
### 服务文件构建
在 src/service 文件夹中新建 userService.js 。

```
|- src/global 
|  ├  ...
|  ├  service
|  |  └  userService.js
```

userService.js 用于对用户相关的数据进行管理，在需要作存储的地方配合 Request 和 Storage 使用，以下我们创建获取验证码、密码登录、短信登录、获取用户信息的方法提供给页面使用。

```javascript
import request from "@/global/request/axios";
import API from "@/global/request/api";
import DataStore from "@/global/storage/index";

const authService = {
  phoneCode({ phone }) {
    return request.post(API.phoneCode, { phone });
  },
  loginPassword({ phone, password }) {
    return request.post(API.loginPassword, { password, phone }).then(res => {
      DataStore.setToken(res.token);
      return res;
    });
  },
  loginSMS({ phone, code }) {
    return request.post(API.loginSMS, { code, phone }).then(res => {
      DataStore.setToken(res.token);
      return res;
    });
  },
  accountLogout() {
    DataStore.clear();
  },
  userInfo() {
    const mapData = DataStore.map.get("userInfo");
    if (mapData) {
      return Promise.resolve(mapData);
    }
    return request.get(API.userInfo).then(res => {
      DataStore.map.set("userInfo", res);
      return res;
    });
  }
};

export default authService;
```

上述我们可以看到，一些对于数据的逻辑我们可以在 service 里面处理，不影响页面的业务逻辑。在登录成功之后我们对 token 进行了存储，在获取用户信息的时候，优先对 map 中的数据进行获取，如果没有再请求获取并存储进 map 数据中。

<a name="aZqDH"></a>
### 登录页调用
在登录页中，引用 userService 并使用其方法，点击获取验证码时候调用 userService.phoneCode ，在点击登录时候调用 userService.loginPassword 或  userService.loginSMS，并在成功后跳转到根页面。

```javascript
import userService from "@/global/service/userService.js";
export default {
  data() {
    return {
			...,
      btnLoading: false
    };
  },
  methods: {
    submitForm(formName) {
      this.$refs[formName].validate(valid => {
        if (valid) {
          let params =
            formName === "passwordFrom" ? this.passwordFrom : this.smsFrom;
          let loginRequest =
            formName === "passwordFrom"
              ? userService.loginPassword
              : userService.loginSMS;
          loginRequest(params).then(() => {
            window.location.href = "/";
          });
        }
      });
    },
    handleSendCode() {
      if (this.disabled) {
        return;
      }
      this.$refs.smsFrom.validateField("phone", errMsg => {
        if (errMsg) return;
        this.disabled = true;
        userService.phoneCode({ phone: this.smsFrom.phone }).then(() => {
          this.$message.success("验证码发送成功！");
          let time = 60;
          this.buttonName = `(${time})秒重新发送`;
          const interval = window.setInterval(() => {
            time -= 1;
            this.buttonName = `(${time})秒重新发送`;
            if (time <= 0) {
              this.buttonName = "重新发送";
              this.disabled = false;
              window.clearInterval(interval);
            }
          }, 1000);
        });
      });
    }
  }
};
```


<a name="Wz0R4"></a>
### 路由重定向
修改 src/router/index.js ，在路由钩子中对我们访问的路径更具 storage 中的 token 进行登录判断，<br />如果没有登录并防伪非登录相关的页面，重定向到登录页，<br />如果以及登录的用户再次去登录页重定向到后台概览页。

```javascript
import Vue from "vue";
import Router from "vue-router";
import routes from "./routes.js";
import NProgress from "nprogress"; //加载条
import "nprogress/nprogress.css"; //加载条样式
import DataStore from "@/global/storage/index";

Vue.use(Router);

const appRouter = new Router({
  mode: "history",
  routes: routes
});

// eslint-disable-next-line
appRouter.beforeEach((to, from, next) => {
  NProgress.start();
  // 没有登录，重定向到登录页
  const TOKEN = DataStore.getToken();
  if (!TOKEN && to.name !== "AccountLogin") {
    next({ name: "AccountLogin", replace: true });
    return;
  }
  if (TOKEN) {
    // 已经登录并且在登录页重定向到主页
    if (to.name === "AccountLogin") {
      next({ name: "Root", replace: true });
      return;
    }
  }
  next();
});

// eslint-disable-next-line
appRouter.afterEach((to, from) => {
  NProgress.done();
});

export default appRouter;

```


<a name="HHiwE"></a>
### 登出
在公共头部的调用 userService 的 logout 方法，同时在 created 生命周期中获取用户信息。

```xml
<template>
  <div class="header-section">
    <div class="header-hd">
      <Breadcrumb />
    </div>
    <div class="header-bd"></div>
    <div class="header-ft">
      <div class="bar-info-container">
        <i class="el-icon-question"></i>
      </div>
      <el-dropdown style="height: 100%;" @command="handleCommand">
        <div class="bar-info-container">
          <i class="el-icon-user-solid userInfo-avatar"></i>
          <span class="userInfo-name">{{ userInfo.name }}</span>
          <i class="el-icon-arrow-down el-icon--right"></i>
        </div>
        <el-dropdown-menu slot="dropdown">
          <el-dropdown-item command="Logout" icon="el-icon-video-pause"
            >退出</el-dropdown-item
          >
        </el-dropdown-menu>
      </el-dropdown>
    </div>
  </div>
</template>

<script>
import Breadcrumb from "@/components/BasicBreadcrumb.vue";
import userService from "@/global/service/userService.js";
export default {
  data() {
    return {
      userInfo: {}
    };
  },
  created() {
    userService.userInfo().then(userInfo => {
      this.userInfo = userInfo;
    });
  },
  methods: {
    handleCommand(command) {
      const handleName = `handle${command}`;
      this[handleName]();
    },
    handleLogout() {
      userService.accountLogout();
    }
  },
  components: {
    Breadcrumb
  }
};
</script>

<style lang="less" scoped>
.header-section {
  position: relative;
  padding: 0 16px;
  height: 64px;
  display: flex;
  z-index: 10;
  background-color: #fff;
  box-shadow: 0 2px 8px #f0f1f2;
  .header-bd {
    flex: 1;
  }
}

.header-hd,
.header-bd,
.header-ft {
  display: flex;
  align-items: center;
}

.bar-info-container {
  display: flex;
  align-items: center;
  height: 100%;
  padding: 0 10px;
  transition: all 0.2s ease;
  cursor: pointer;
  &:hover {
    background-color: #ecf5ff;
  }
  .userInfo-name {
    font-size: 14px;
    vertical-align: middle;
  }
  .userInfo-avatar {
    display: inline-block;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    background-color: #ccc;
    border-radius: 50%;
    outline: none;
    margin: 0 10px;
  }
}
</style>
```


<a name="BK4rB"></a>
## 权限
在一个中后台页面中，往往涉及到非常多的功能和人员，在某些时候我们希望某些功能仅对特定的人员开放，这时候我们就需要对页面的展示进行权限的管理。权限需要和菜单联动，如果该登录着没有菜单中对应的权限，菜单不展示对应选项，同时我们还需要对路由进行动态的加载，如果当前用户没有对应路由的权限我们就不添加到全局的路由中，一方面减少内存的损耗，另一方面如果访问对应的路由会自动重定向到 404 页面。

<a name="rezA5"></a>
### 定义路由权限
修改 src/router/routesPermission.js 后台路由，给需要权限的路由地址加上 permission 权限，如下我们给文章管理的路由加上 article-manage 的权限配置，给企业管理加上 setting-company 的权限设置，给用户管理添加上 setting-manage 的权限设置。

> 注意: 不要复制粘贴，看清楚添加 permission 熟悉的地方


```javascript
// ... 注意不要复制粘贴，看清楚添加 permission 熟悉的地方

export default [
  {
    path: "/",
    name: "Root",
    component: BasicLayout,
    redirect: { name: "Dashboard" },
    children: [
      {
        path: "/dashboard",
        name: "Dashboard",
        component: Dashboard,
        meta: {
          nav: {
            icon: "el-icon-pie-chart",
            title: "概况"
          },
          breadcrumb: {
            title: "概况"
          }
        }
      },
      {
        path: "/article",
        name: "ArticleRoot",
        // 文章管理权限
        permission: "article-manage",
        component: { render: h => h("router-view") },
        meta: {
          nav: {
            icon: "el-icon-tickets",
            title: "文章"
          },
          breadcrumb: {
            title: "文章"
          }
        },
        children: [...]
      },
      {
        path: "/setting",
        name: "settingRoot",
        component: { render: h => h("router-view") },
        meta: {
          nav: {
            icon: "el-icon-setting",
            title: "设置"
          },
          breadcrumb: {
            title: "设置"
          }
        },
        children: [
          {
            path: "/setting/company",
            name: "SettingCompany",
            component: SettingCompany,
            // 公司设置权限
            permission: "setting-company",
            meta: {
              nav: {
                icon: "el-icon-office-building",
                title: "公司设置"
              },
              breadcrumb: {
                title: "公司"
              }
            }
          },
          {
            path: "/setting/manager",
            name: "SettingManagerRoot",
            component: { render: h => h("router-view") },
            redirect: { name: "SettingManager" },
            // 公司人员设置权限
            permission: "setting-manager",
            meta: {
              nav: {
                icon: "el-icon-user",
                title: "管理员设置"
              },
              breadcrumb: {
                title: "管理员",
                replace: true
              }
            },
            children: [...]
          }
        ]
      }
    ]
  }
];
```

<a name="iiqqR"></a>
### 修改公共路由
src/router/routerCommon.js 修改公共路由的方法，考虑到之后我们要动态加载权限，匹配所有的路由的路由应该放在最后，因此我们需要先注释公共路由部分匹配所有路由的路由。之后我们会将其提取到路由拼接的方法中。

```javascript
const AccountLogin = () =>
  import(/* webpackChunkName: "account" */ "@/views/AccountLogin.vue");
const Error404 = () =>
  import(/* webpackChunkName: "errorp" */ "@/views/Error404.vue");

export default [
  {
    path: "/login",
    component: AccountLogin,
    name: "AccountLogin"
  },
  {
    path: "/404",
    name: "Error404",
    component: Error404
  },
  // {
  //   path: "*",
  //   redirect: { name: "Error404" }
  // }
];
```

<a name="iKD8q"></a>
### 权限路由过滤
修改 src/router/routes.js 通过请求从服务器中获取到用户权限相关的数据，例如我们的 userService.userInfo 中的 permissions，然后根据 permissions 中的字段结合在上一章节菜单路由递归的方法筛选出拥有权限的路由，当路由中没有 permission 属性代表都可以访问，如果存在 permission 属性，就和用户的 permissions 中的值进行匹配，如果在其中则显示，不然不显示。

同时在筛选结果最后加上全路径匹配路由。

```javascript
import RoutesCommon from "./routesCommon.js";
import RoutesPermission from "./routesPermission.js";
import userService from "@/global/service/userService.js";

// 404
const matchAllRouter = [
  {
    path: "*",
    redirect: { name: "Error404" }
  }
];

// 权限路由过滤
const filterPermissionRoutes = (routes, permissions) => {
  const filterRoutes = [];
  routes.forEach(data => {
    const route = { ...data };
    const notPermission = !route.permission;
    const hasPermission = permissions.includes(route.permission);
    const passPermission = notPermission || hasPermission;
    let hasPath = true;
    if (route.children) {
      route.children = filterPermissionRoutes(data.children, permissions);
      if (route.children.length === 0) {
        hasPath = false;
      }
    }
    if (passPermission && hasPath) {
      filterRoutes.push(route);
    }
  });
  return filterRoutes;
};

// 返回过滤后的权限路由
export const fetchFilterPermissionRoutes = async () => {
  const userInfo = await userService.userInfo();
  const { permissions } = userInfo;
  const routes = RoutesPermission;
  console.log(permissions);
  return filterPermissionRoutes(routes, permissions).concat(matchAllRouter);
};

export const commonRoutes = RoutesCommon;

export default RoutesPermission.concat(RoutesCommon);

```

<a name="IwkNX"></a>
### 动态添加路由
修改 src/outer/index.js 在路由钩子中定义 hasAddRouter 是否添加过，如果已经登录且没有添加过的话，引用 fetchFilterPermissionRoutes 方法返回的路由使用 addRoutes 方法添加。

```javascript
import Vue from "vue";
import Router from "vue-router";
import { fetchFilterPermissionRoutes, commonRoutes } from "./routes.js";
import NProgress from "nprogress"; //加载条
import "nprogress/nprogress.css"; //加载条样式
import DataStore from "@/global/storage/index";

Vue.use(Router);
const appRouter = new Router({
  mode: "history",
  routes: commonRoutes
});

appRouter.hasAddRouter = false;
// eslint-disable-next-line
appRouter.beforeEach(async (to, from, next) => {
  NProgress.start();
  // 没有登录，重定向到登录页
  const TOKEN = DataStore.getToken();
  if (!TOKEN && to.name !== "AccountLogin") {
    next({ name: "AccountLogin", replace: true });
    return;
  }

  if (TOKEN) {
    if (!appRouter.hasAddRouter) {
      const filterRoutes = await fetchFilterPermissionRoutes();
      appRouter.hasAddRouter = true;
      appRouter.addRoutes(filterRoutes);
      // 确保路由已经添加完成
      next({ ...to, replace: true });
      return;
    }

    // 已经登录并且在登录页重定向到主页
    if (to.name === "AccountLogin") {
      next({ name: "Root", replace: true });
      return;
    }
  }
  next();
});

// eslint-disable-next-line
appRouter.afterEach((to, from) => {
  NProgress.done();
});

export default appRouter;

```

<a name="uStsk"></a>
### 修改菜单路由
修改 src/components/BasicLayoutSiderMenu.vue 中获取的路由，原来是获取所有的路由，现在我们需要获取 fetchFilterPermissionRoutes 返回的经过筛选之后的拥有的权限路由，这样菜单导航才可根据权限的不同动态更新。

```javascript
// import routes from "@/router/routesPermission";
import { fetchFilterPermissionRoutes } from "@/router/routes.js";

export default {
  data() {
    return {
      path: this.$route.path,
      filterRoutes: []
    };
  },
  created() {
    this.getRoutes();
  },
  watch: {
    $route(to) {
      this.path = to.path;
    }
  },
  methods: {
    getRoutes() {
      // fetchFilterPermissionRoutes 是 async 函数返回的是个 Promise
      fetchFilterPermissionRoutes().then(routes => {
        this.filterRoutes = this.filterNavigator(routes);
      });
    },
    filterNavigator(node) {
      let result = [];
      node.forEach(data => {
        if (data.meta && data.meta.nav) {
          let item = {
            path: data.path,
            name: data.name,
            meta: data.meta
          };
          if (data.children) {
            item.children = this.filterNavigator(data.children);
          }
          result.push(item);
        } else if (data.children) {
          this.filterNavigator(data.children).forEach(item =>
            result.push(item)
          );
        }
      });
      return result;
    },
    hasNavChildren(route) {
      const children = route.children || [];
      return children.some(data => data.meta && data.meta.nav);
    }
  }
};
```

 最后我们修改 easyMook 的 userinfo 的 API 中返回的 permissions 字段，尝试修改数组里面的值，观察菜单导航的动态变化，访问权限之外的路由，返回 404 页面。
